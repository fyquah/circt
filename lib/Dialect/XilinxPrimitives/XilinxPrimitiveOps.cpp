#include "mlir/IR/Builders.h"

#include "circt/Dialect/HW/HWTypes.h"
#include "circt/Dialect/XilinxPrimitives/XilinxPrimitivesOps.h"
#include "mlir/IR/OpImplementation.h"
#include "mlir/Support/LogicalResult.h"

/* Common printOp for all operation. Specified a separate function to prevent code bloat. */
static void printOp(const char* mnemonic, mlir::OpAsmPrinter &printer, mlir::Operation* op)
{
  bool isFirst = true;

  printer << mnemonic << " ";
  for (auto operand : op->getOperands()) {
    if (!isFirst) {
      printer << ", ";
    }
    isFirst = false;
    printer << operand << " ";
  }
  printer.printOptionalAttrDict(op->getAttrs());
  auto opResults = op->getOpResults();

  if (opResults.size() == 0) {
  } else if (opResults.size() == 1) {
    printer << " : " << opResults.front().getType();
  } else {
    printer << " : (";
    isFirst = true;
    for (auto result :opResults) {
      if (!isFirst) {
        printer << ", ";
      }
      isFirst = false;
      printer << result.getType() << " ";
    }
    printer << " )";
  }
}

static mlir::ParseResult parseOp(const llvm::ArrayRef<std::tuple<const char*, circt::hw::PortDirection, uint64_t>> primitivePortsInfo,
                                      mlir::OpAsmParser &parser,
                                      mlir::OperationState &result) {

  size_t numOperands = 0;
  size_t numResults = 0;
  llvm::SmallVector<::mlir::Type> expectedOperandTypes;

  for (auto portInfo : primitivePortsInfo) {
    auto portDirection = std::get<1>(portInfo);
    uint64_t width = std::get<2>(portInfo);
    auto integerType = parser.getBuilder().getIntegerType(width);
    switch (portDirection) {
      case circt::hw::PortDirection::INPUT:
        numOperands++;
        expectedOperandTypes.push_back(integerType);
        break;
      case circt::hw::PortDirection::INOUT:
        numOperands++;
        expectedOperandTypes.push_back(circt::hw::InOutType::get(integerType));
        break;
      case circt::hw::PortDirection::OUTPUT:
        numResults++;
        break;
    }
  }

  // Parse all the input operands
  llvm::SmallVector<mlir::OpAsmParser::OperandType> inputOperands(numOperands);
  for (size_t i = 0; i < numOperands; i++) {
    if (parser.parseOperand(inputOperands[i])) {
      return mlir::failure();
    }

    if (i != numOperands - 1) {
      return mlir::failure();
    }
  }

  // Attributes
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();

  // We are done if this primitive has no return values.
  if (numResults == 0) {
    return ::mlir::success();
  }

  // Result types
  llvm::SmallVector<::mlir::Type> outputTypes(numResults);
  if (parser.parseColon())
    return ::mlir::failure();

  if (numResults > 1) {
    if (parser.parseLParen())
      return ::mlir::failure();
  }

  if (parser.parseType(outputTypes[0]))
    return ::mlir::failure();

  for (size_t i = 1; i < numResults ; i++) {
    if (parser.parseComma())
      return ::mlir::failure();
    if (parser.parseType(outputTypes[i]))
      return ::mlir::failure();
  }

  if (numResults > 1) {
    if (parser.parseRParen())
      return ::mlir::failure();
  }

  for (auto outputType : outputTypes) {
    result.addTypes(outputType);
  }

  for (size_t i = 0; i < numOperands; i++) {
    if (parser.resolveOperands(inputOperands[i], expectedOperandTypes[i], result.operands))
      return ::mlir::failure();
  }

  return ::mlir::success();

}

// Provide the autogenerated implementation guts for the Op classes.
#define GET_OP_CLASSES
#include "circt/Dialect/XilinxPrimitives/XilinxPrimitives.cpp.inc"

// Provides the generated implementation for turning xilinx primitives into operations.
#include "circt/Dialect/XilinxPrimitives/XilinxRawPrimitivesOps.cpp.inc"
